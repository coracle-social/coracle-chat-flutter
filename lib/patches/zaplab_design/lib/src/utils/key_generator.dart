import 'package:bip39/bip39.dart' as bip39;
import 'package:bip39/src/wordlists/english.dart' as bip39_words;
import 'package:hex/hex.dart' show HEX;
import 'package:crypto/crypto.dart';
import 'package:collection/collection.dart';
import 'package:bech32/bech32.dart';
import 'package:pointycastle/ecc/curves/secp256k1.dart';
import 'package:pointycastle/ecc/api.dart';
import 'emoji_list.dart';
import 'dart:math';

class KeyGeneratorResult {
  final String nsec;
  final String npub;
  final String mnemonic;
  final List<String> emojis;

  const KeyGeneratorResult({
    required this.nsec,
    required this.npub,
    required this.mnemonic,
    required this.emojis,
  });
}

class LabKeyGenerator {
  /// Converts a Nostr private key (nsec) to a BIP39 mnemonic
  /// Only works for nsecs generated by our method
  static String? nsecToMnemonic(String nsec) {
    try {
      // Decode Bech32
      final decoded = const Bech32Codec().decode(nsec);
      final privateKeyBytes = _convertBits(decoded.data, 5, 8, false);

      // Use first 16 bytes (128 bits) for the mnemonic
      final entropy = privateKeyBytes.sublist(0, 16);
      final entropyHex = HEX.encode(entropy);

      // Generate 12-word mnemonic
      return bip39.entropyToMnemonic(entropyHex);
    } catch (e) {
      print('Error converting nsec to mnemonic: $e');
      return null;
    }
  }

  /// Converts a BIP39 mnemonic to a Nostr private key (nsec)
  /// Always generates a valid nsec using our method
  static String mnemonicToNsec(String mnemonic) {
    // Get the entropy from the mnemonic
    final entropyHex = bip39.mnemonicToEntropy(mnemonic);
    final firstHalf = HEX.decode(entropyHex);

    // Generate second half from first half
    final secondHalf = sha256.convert(firstHalf).bytes.sublist(0, 16);

    // Combine for full 32-byte private key
    final privateKeyBytes = [...firstHalf, ...secondHalf];

    // Ensure the key is valid (first byte must be less than 0x80)
    if (privateKeyBytes[0] >= 0x80) {
      privateKeyBytes[0] = privateKeyBytes[0] & 0x7F;
    }

    // Convert to Bech32
    final data = _convertBits(privateKeyBytes, 8, 5, true);
    final bech32 = const Bech32Codec().encode(Bech32('nsec', data));

    return bech32;
  }

  /// Checks if a Nostr private key was generated using our method
  static bool isOurKey(String nsec) {
    try {
      // Decode Bech32
      final decoded = const Bech32Codec().decode(nsec);
      final privateKeyBytes = _convertBits(decoded.data, 5, 8, false);

      final firstHalf = privateKeyBytes.sublist(0, 16);
      final secondHalf = privateKeyBytes.sublist(16, 32);
      final expectedSecondHalf = sha256.convert(firstHalf).bytes.sublist(0, 16);

      return const ListEquality().equals(secondHalf, expectedSecondHalf);
    } catch (e) {
      return false;
    }
  }

  /// Converts a Nostr private key to emojis
  /// Only works for nsecs generated by our method
  static List<String>? nsecToEmojis(String nsec) {
    try {
      // Get the mnemonic from the nsec
      final mnemonic = nsecToMnemonic(nsec);
      if (mnemonic == null) return null;

      // Split into words and get their indices
      final words = mnemonic.split(' ');
      final indices = words.map((word) {
        final index = bip39_words.WORDLIST.indexOf(word);
        if (index == -1) {
          throw Exception('Word not found in BIP39 word list: $word');
        }
        return index;
      }).toList();

      // Map indices to emojis
      return indices.map((i) => emojis[i]).toList();
    } catch (e) {
      return null;
    }
  }

  /// Converts emojis back to a Nostr private key
  static String emojisToNsec(List<String> inputEmojis) {
    try {
      // Convert each emoji to its index
      final indices = inputEmojis.map((emoji) {
        final index = emojis.indexOf(emoji);
        if (index == -1) {
          throw Exception('Emoji not found in emoji list: $emoji');
        }
        return index;
      }).toList();

      // Convert indices to words
      final words = indices.map((i) {
        if (i >= bip39_words.WORDLIST.length) {
          throw Exception('Index out of range: $i');
        }
        return bip39_words.WORDLIST[i];
      }).toList();

      // Join words into mnemonic
      final mnemonic = words.join(' ');

      // Get the entropy from the mnemonic
      final entropyHex = bip39.mnemonicToEntropy(mnemonic);
      final firstHalf = HEX.decode(entropyHex);

      // Generate second half from first half
      final secondHalf = sha256.convert(firstHalf).bytes.sublist(0, 16);

      // Combine for full 32-byte private key
      final privateKeyBytes = [...firstHalf, ...secondHalf];

      // Ensure the key is valid (first byte must be less than 0x80)
      if (privateKeyBytes[0] >= 0x80) {
        privateKeyBytes[0] = privateKeyBytes[0] & 0x7F;
      }

      // Convert to Bech32
      final data = _convertBits(privateKeyBytes, 8, 5, true);
      final bech32 = const Bech32Codec().encode(Bech32('nsec', data));

      return bech32;
    } catch (e) {
      print('Error converting emojis to nsec: $e');
      throw Exception('Failed to convert emojis to nsec: $e');
    }
  }

  /// Converts a Nostr private key (nsec) to a public key (npub)
  static String nsecToNpub(String nsec) {
    // Decode Bech32
    final decoded = const Bech32Codec().decode(nsec);
    final privateKeyBytes = _convertBits(decoded.data, 5, 8, false);

    // Generate public key using secp256k1
    final curve = ECCurve_secp256k1();
    final domainParams = ECDomainParameters('secp256k1');
    final basePoint = domainParams.G;
    final privateKey = BigInt.parse(HEX.encode(privateKeyBytes), radix: 16);
    final publicKey = basePoint * privateKey;

    // Get the X coordinate of the public key point
    final x = publicKey?.x?.toBigInteger();

    if (x == null) {
      throw Exception('Failed to generate public key X coordinate');
    }

    // Convert to bytes (32 bytes)
    final xBytes = x.toRadixString(16).padLeft(64, '0');
    final publicKeyBytes = HEX.decode(xBytes);

    // Convert to Bech32
    final data = _convertBits(publicKeyBytes, 8, 5, true);
    final bech32 = const Bech32Codec().encode(Bech32('npub', data));

    return bech32;
  }

  /// Converts a Nostr private key (nsec) to a hex-encoded private key
  static String nsecToHex(String nsec) {
    // Decode Bech32
    final decoded = const Bech32Codec().decode(nsec);
    final privateKeyBytes = _convertBits(decoded.data, 5, 8, false);
    return HEX.encode(privateKeyBytes);
  }

  /// Generates a new random key pair with mnemonic and emojis
  static KeyGeneratorResult generateNewKeys() {
    // Generate random 16 bytes (128 bits) for the first half
    final random = Random.secure();
    final firstHalf = List<int>.generate(16, (_) => random.nextInt(256));

    // Generate second half from first half
    final secondHalf = sha256.convert(firstHalf).bytes.sublist(0, 16);

    // Combine for full 32-byte private key
    final privateKeyBytes = [...firstHalf, ...secondHalf];

    // Ensure the key is valid (first byte must be less than 0x80)
    if (privateKeyBytes[0] >= 0x80) {
      privateKeyBytes[0] = privateKeyBytes[0] & 0x7F;
    }

    // Convert to Bech32 for nsec
    final nsecData = _convertBits(privateKeyBytes, 8, 5, true);
    final nsec = const Bech32Codec().encode(Bech32('nsec', nsecData));

    // Generate public key
    final publicKeyBytes = sha256.convert(privateKeyBytes).bytes;
    final npubData = _convertBits(publicKeyBytes, 8, 5, true);
    final npub = const Bech32Codec().encode(Bech32('npub', npubData));

    // Generate mnemonic from first half
    final entropyHex = HEX.encode(firstHalf);
    final mnemonic = bip39.entropyToMnemonic(entropyHex);

    // Convert nsec to emojis
    final emojis = nsecToEmojis(nsec);
    if (emojis == null) {
      throw Exception('Failed to generate emojis from nsec');
    }

    return KeyGeneratorResult(
      nsec: nsec,
      npub: npub,
      mnemonic: mnemonic,
      emojis: emojis,
    );
  }

  /// Simple hash function to convert a word to a number
  static int _hashString(String input) {
    var hash = 0;
    for (var i = 0; i < input.length; i++) {
      hash = (hash * 31 + input.codeUnitAt(i)) & 0xFFFFFFFF;
    }
    return hash;
  }

  static String generateMnemonic() {
    final random = Random.secure();
    final entropy = List<int>.generate(16, (_) => random.nextInt(256));
    final hexString =
        entropy.map((b) => b.toRadixString(16).padLeft(2, '0')).join();
    return bip39.entropyToMnemonic(hexString);
  }

  static bool verifyNsecChecksum(String nsec) {
    try {
      final decoded = const Bech32Codec().decode(nsec);
      return decoded.hrp == 'nsec' && decoded.data.isNotEmpty;
    } catch (e) {
      return false;
    }
  }

  static List<int> _convertBits(
      List<int> data, int fromBits, int toBits, bool pad) {
    var acc = 0;
    var bits = 0;
    final result = <int>[];
    final maxv = (1 << toBits) - 1;

    for (var value in data) {
      if (value < 0 || (value >> fromBits) != 0) {
        throw Exception('Invalid value: $value');
      }
      acc = (acc << fromBits) | value;
      bits += fromBits;
      while (bits >= toBits) {
        bits -= toBits;
        result.add((acc >> bits) & maxv);
      }
    }

    if (pad) {
      if (bits > 0) {
        result.add((acc << (toBits - bits)) & maxv);
      }
    }

    return result;
  }
}
